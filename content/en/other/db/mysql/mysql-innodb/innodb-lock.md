---
title: Mysql InnoDB 锁
date: 2021-03-22
weight: 202103222100
---

[TOC]

### 1. 什么是锁

锁机制用于管理对共享资源的并发访问，提供数据的完整性和一致性。

### 2. lock与latch
- latch  
  闩锁(轻量级的锁)作用对象是并发线程，要求锁定的时间要非常短。持续时间太长则性能就会非常差。在InnoDb中latch又分为两种：mutex(互斥量)和rwlock（读写锁）。作用用来保证并发线程操作临界资源的正确性(没有死锁的检查机制)
- lock  
  lock作用对象是事务，用来锁定数据库中的对象(表、页、行)并且一般lock的对象仅在事务commit或rollback后进行释放(不同的事务隔离级别释放的时间可能不同)，有死锁的检测机制

区别列表：

|          | lock                                                | latch                  |
| -------- | --------------------------------------------------- | ---------------------- |
| 对象     | 事务                                                | 线程                   |
| 保护     | 数据库内容                                          | 内存数据结构           |
| 持续时间 | 整个事务过程                                        | 临界资源               |
| 模式     | 行锁、表锁、意向锁                                  | 读写锁、互斥量         |
| 死锁     | 通过waits-for graph、time out等机制进行死锁检测处理 | 无死锁的检测与处理机制 |
| 存在于   | Lock Mannager的哈希表中                             | 每个数据结构的对象     |


> latch查看命令：show engine innodb mutex;

### 3. InnoDB存储引擎中的锁
在InnoDB中使用的锁：

- **共享锁和排他锁**
- **意向锁**
- **行锁**
- **间隙锁**
- **Next-Key Locks**
- **插入意向锁**
- **AUTO-INC 锁**
- **基于空间索引的锁**

锁定的类型：

- 行级锁
- 表级锁

#### 3.1 行级锁
InnoDb存储引擎实现了如下两种标准的行级锁：
1. 共享锁(S Lock),允许事务读一行数据
2. 排他锁(X Lock)，允许事务删除或者更新一行数据

|      |   X    |   S    |
| :--: | :----: | :----: |
|  X   | 不兼容 | 不兼容 |
|  S   | 不兼容 |  兼容  |

> 如果一个事务T1已经获得了行R的共享锁，那么另一个事务T2可以立刻获得行R的共享锁，这种情况为锁兼容。但T3事务想获取拍他锁则必须等待事务T1、T2释放R行上的共享锁。这种情况称为锁不兼容。从表格可以看出来X锁不和任何锁兼容，只有S锁和S锁兼容。

#### 3.2 表级锁(意向锁)
InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持不同粒度上进行加锁操作，InnoDB支持一种额外的锁方式。称之为意向锁。
1. 意向共享锁
2. 意向排他锁

由于InnoDB存储支持的是行级别的锁，以此意向锁其实不会阻塞除全表扫描以外的任何请求。故表级意向锁与行级锁的兼容性如下：
|      |   X    |   IX   |   S    |   IS   |
| :--: | :----: | :----: | :----: | :----: |
|  X   | 不兼容 | 不兼容 | 不兼容 | 不兼容 |
|  IX  | 不兼容 |  兼容  | 不兼容 |  兼容  |
|  S   | 不兼容 | 不兼容 |  兼容  |  兼容  |
|  IS  | 不兼容 |  兼容  |  兼容  |  兼容  |


> 查看当前锁的信息命令：show engine innodb status;  
> 通过information_schema中的表innodb_trx、innodb_locks、innodb_lock_waits通过三张表来分析可能出在锁的问题。

### 4. 一致性非锁定读
InnoDB存储引擎通过行多版本控制的方式来去读当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或者UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反的InnoDB会去读取行的一个快照数据。  
非锁定读机制极大的提高了数据库的并发，InnoDB存储引擎默认设置就是非锁定读。但是在不同的事务隔离级别下读取方式不同。并不是每个事务隔离级别下都采用的非锁定的一致性读。
> 一个记录可能有不止一个快照数据，一般称这种技术为多版本控制技术。由此带来的并发控制，称之为多版本并发控制也就是MVCC

在事务隔离级别READ COMMITTED和REPEATABLE READ(InnoDB存储引擎的默认事务隔离级别)下InnoDB存储引擎使用非锁定的一致性读。然而对于快照数据的定义却不相同。
- Read Committed事务隔离下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据
- Repeatable read事务隔离级别对于快照数据，非一致性读总是读取事务开始时的行数据版本。

例子：

### 5. 一致性锁定读
在默认配置下，事务隔离级别为Repeatable read模式下，InnoDB存储引擎的SELECT操作使用一致性非锁定读，但是在某些情况下需要显示的对数据库读取操作进行加锁以保证数据库逻辑的一致性，这就要求数据库支持加锁语句，InnoDB存储引擎对Select语句支持两种一致性的锁定读操作：
1. SELECT .... FOR UPDATE
2. SELECT .... LOCK IN SHARE MODE.