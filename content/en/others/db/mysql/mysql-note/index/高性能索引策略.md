---
title: 高性能索引策略
categories:
  - 数据库
  - MYSQL
  - 高性能MySQL读书笔记
  - 索引
tags:
  - 数据库
  - MYSQL
  - 高性能MySQL读书笔记
  - 索引
abbrlink: d14da1ac
date: 2019-07-16 17:50:36
---
**从索引的角度来提高数据库速度**

### 1. 独立的列

如果查询过程中不是独立的列，则Mysql就不能使用索引。**独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。** 始终将索引列单独放在比较符的一侧。

```sql
select actor_id from actor where actor_id+1 = 5
```

上面的SQL就不能使用到索引。这种情况应该避免！

### 2. 前缀索引和索引的选择

有时候需要索引很长的字符列，这会让索引变得大而且慢！**通过Hash索引可以解决这个问题**，但是有时候这样做还不够。可以从以下方面来着手：

- **索引开始的部分字符串**

  **优点：大大的节约索引的空间，提高索引的效率。但这样也会降低索引的选择性。**

  >**什么是索引的选择性？**
  >
  >不重复的索引值（也叫做基数）和表中纪录总数(#T)的比值，范围从1/#T ~ 1 之间。
  >
  >索引的选择性越高则查询效率越高，因为选择性高的索引能够过滤掉更多的行。唯一索引的选择性为1，这是最好的索引选择性，性能也最好。

  一般情况下某个列前缀的选择性也是足够高的，**足够满足性能查询。对于BLOB、和TEXT或者很长的varchar。必须使用前缀索引。** 因为MySQL不允许索引这些列的完整长度。

  > **使用诀窍：**
  >
  > 选择足够长的前缀以保证较高的选择性，同时又不能太长(节约空间)。前缀足够长，以使得前缀索引的选择性接近于索引整个列。（索引前缀的基数接近于完整列的基数）

  如何选择合适的长度演示：

  比如我要查询city使用前缀值为多少比较合适？

  ```sql
  --获取city的选择性
  SELECT COUNT(DISTINCT city)/COUNT(*) FROM city_demo 
  --获取不同前缀的选择性
  SELECT 
  COUNT(DISTINCT LEFT(city,3))/COUNT(*) as a1,
  COUNT(DISTINCT LEFT(city,4))/COUNT(*) as a2,
  COUNT(DISTINCT LEFT(city,5))/COUNT(*) as a3,
  COUNT(DISTINCT LEFT(city,6))/COUNT(*) as a4
  FROM city_demo 
  
  ```

  通过对比找出和第一个sql语句最接近的数值(当然可能长度还更长)。假如是LEFT(city，5)这个就已经已经接近了。那么创建前缀索引：

  ```sql
  mysql>ALTER TABLE city_demo ADD KEY(ctiy(7));
  ```

  缺点：无法使用前缀索引做Order By和Group By，同样也无法使用前缀索引做覆盖扫描。

### 3. 多列索引

对于索引来看一下下面的通常的做法：

```sql
CREATE TABLE `vet_friend` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) DEFAULT NULL COMMENT '用户Id',
  `friend_id` bigint(20) DEFAULT NULL COMMENT '朋友的Id',
  `friend_ship` tinyint(2) DEFAULT '0' COMMENT '状态 0-待同意 1-已同意 2-已拒绝',
  `gmt_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `gmt_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_left_id` (`user_id`),
  KEY `idx_right_id` (`friend_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='好友表';
```

在多个列上面单独建立索引大部分情况并不能提高MySQL的查询效率(通过下面的执行计划)

```sql
EXPLAIN SELECT * FROM vet_activity WHERE gmt_created > date_format('2019-03-25 15:40:07', '%Y%m%d%H%i%s') 

EXPLAIN SELECT * FROM vet_activity WHERE gmt_created = date_format('2019-03-25 15:40:07', '%Y%m%d%H%i%s') AND organization = 'organization'
```

通过查看执行计划：

```
+----+-------------+--------------+------+------------------+------+---------+------+------+-------------+
| id | select_type | table        | type | possible_keys    | key  | key_len | ref  | rows | Extra       |
+----+-------------+--------------+------+------------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | vet_activity | ALL  | gmtCreated_index | NULL | NULL    | NULL |   32 | Using where |
+----+-------------+--------------+------+------------------+------+---------+------+------+-------------+

+----+-------------+--------------+------+-------------------------------------+--------------------+---------+-------+------+------------------------------------+
| id | select_type | table        | type | possible_keys                       | key                | key_len | ref   | rows | Extra                              |
+----+-------------+--------------+------+-------------------------------------+--------------------+---------+-------+------+------------------------------------+
|  1 | SIMPLE      | vet_activity | ref  | gmtCreated_index,organization_index | organization_index | 131     | const |    1 | Using index condition; Using where |
+----+-------------+--------------+------+-------------------------------------+--------------------+---------+-------+------+------------------------------------+
```

在某些情况下没有一个单独索引是非常有效的比如下面的这个SQL语句：

```sql
select film_id, actor_id FROM film_actor where actor_id = 1 or film_id = 1
```

如果在EXPLAIN中看到有索引合并的情况，最好检查一下查询和表结构。

### 4. 选择合适的索引顺序

正确的索引顺序依赖于使用索引的查询，并且同时需要考虑如何更好的满足排序和分组的需要，(适用于BTree索引，hash不会想B-Tree那样按照顺序存储)。

**如何选择索引的列顺序有一个法则经验：将选择性搞的列放在索引的最前列。** (不是说在建表语句中谁在前面就放在前面)。

当不需要考虑排序和分组的时候，选择性高的列放在前面通常很好 —— 索引的作用只是用于优化WHERE后面的条件查找，这样索引能够快速的过滤出来所需要的行，对于WHERE子句中只使用了索引的部分前缀列的查询来说选择性也更加高。

例子：

```sql
select * from payment where staff_id = 2 and customer_id = 548
```

这个应该怎么创建索引呢？ (staff_id,customer_id) 还是颠倒过来。通常的方法如下：

- **根据业务判断哪个字段的选择性搞就把那个字段放在前面**

- **运行一段时间后用SQL进行统计**

  ```sql
  select count(DISTINCT staff_id)/count(*) as a1,count(DISTINCT customer_id)/count(*) as a2 from payment 
  ```

  将选择性高的列放在前面，但是对于一些特殊的用户这个需要注意。

### 5. 聚簇索引

**什么是聚簇索引？**

**聚簇索引并不是一种单独的索引类型，二手一种数据存储方式。具体依赖存储引擎的实现方式，InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。当表有聚簇索引的时候，他的数据行实际上存放在索爷的叶子节点(无法同时吧数据行存放在不停的地方，所以一个表只能有一个聚簇索引)**

![图](https://github.com/mxsm/document/blob/master/image/database/%E9%AB%98%E6%80%A7%E8%83%BDMysql%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%B4%A2%E5%BC%95/mysqBTree%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E8%AF%B4%E6%98%8E.JPG?raw=true)

上图展示了InnoDB聚簇索引的存储。

MySQL的InnoDB是通过主键聚集数据。

**聚簇索引的优点：**

- **把相关数据保存在一起，提高了I/O的性能**
- **数据访问更快。聚簇索引将索引 和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引快**
- **使用覆盖索引扫描的查询可以直接使用页节点中的主键值**

**缺点：**

- **聚簇数据提高了I/O密集型应用的性能，但是如果放在内存中聚簇索引就没有什么优势了**

- **插入速度严重依赖插入顺序**

  按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。如果不睡按照主键顺序加载数据，那么最好加载完成后使用 **`OPTIMIZE TABLE`** 命令重新组织一下表。

- **更新聚簇索引的代价很高**

  因为会强制InnoDB将每个被更新的行移动到新的位置。

- **基于聚簇索引的表插入新，或者主键被更新导致需要移动的时候，可能面临"页分裂"的问题**

  当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行。这就是一场页分裂操作。页分裂会导致表占用更多的磁盘空间。

- **聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候**

- **二级索引(非聚簇索引)可能比想象的要更大，因为在二级索引的叶子节点包含了引用的主键列**

- **二级索引访问需要两次索引查找，而不是一次**

  **`InnoDB的二级索引和聚簇索引很不相同。InnoDB二级索引的叶子节点存储的不是行指针，而是主键值。并以此作为行指针。好处就是减少行移动或者行数据页分裂时二级索引的维护工作。使用主键值当做指针会让二级索引占用更多的空间，好处就是InnoDB移动行无须更新二级索引中的这个指针`**

**插入乱序数据聚簇索引的缺点：**

插入过程中新的聚簇索引(InnoDB表的主键)，主键值不应定比之前插入的大，索引InnoDB无法简单的总是把新的行插入到索引的最后，而是需要为新的行寻找合适的位置 — 通常是已有的数据的中间位置 —— 并且分配空间。增加了额外的工作，并且导致舒服分布不够优化。

- 写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中。InnoDB在插入之前不得不现在到并且从实盘读取目标页到内存中。则将导致大量的随机I/O。
- 因为写入乱序，InnoDB不得不频繁的做页的分裂操作，以便为新的行分配空间。页分配会导致移动大量的数据。一次插入至少要修改三个页而不是一个页。
- 由于频繁的页分裂，页会变得稀疏并被不规则的填充，索引最终数据会碎片。

> **顺序的主键什么时候会造成更坏的结果？**
>
> 对于高并发的工作负荷，在InnoDB中按主键顺序插入可能会造成很明显的争用。主键的上界会成为"热点"，因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是AUTO_INCREMENT锁机制。
>
> 解决方式：可能需要考虑重新设计表或者应用，或者更改innodb_autoinc_lock_mode配置。

### 6. 覆盖索引

> **什么是覆盖索引？**
>
> 一个索引包含(或者覆盖)所有需要查询的字段的值

**覆盖索引的好处：**

- 索引条目通常远少于数据行大小，所以如果只需要读取索引，那MySQL就会极大的减少数据访问量。
- 索引按照列值顺序存储的，所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多。
- 由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值。所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。

不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值。而哈希索引，空间索引，和全文索引等等都不存储索引列的值。

> 在 EXPLAIN的Extra列可以看到"Using index"的信息说明使用了覆盖索引。

看一个不能使用覆盖索引的SQL：

```sql
select * from products where actor = 'sendaaa' and title like '%APPOLLO%'
```

无法使用索引的两个原因：

- 没有任何索引能够覆盖这个查询。— 查询了所有的列。而没有任何索引覆盖了所有的列。
- MySQL不能在索引中执行LIKE操作。

### 7. 使用索引扫描来做排序

MySQL有两种方式可以生成有序的结果：

- 排序操作

- 索引顺序扫描

  EXPLAIN出来的type列的值为"index"，则说明MySQL使用了索引扫描来排序。

只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序反方向(倒序或者正序)都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY 子句引用的字段全部为第一个表时，才能使用索引做排序。 ORDER BY 子句和查找类型查询的限制是一样的，需要满足索引的最左前缀的要求。

### 8. 冗余索引和重复索引

**重复索引：相同的列上面按照相同的顺序创建的相同类型的索引。**

```sql
create table test(
ID int not null primary key,
  a int not null,
  UNIQUE(ID)
)engine=Innodb
```

上面就是创建了重复索引。

**冗余索引：一个索引包含了另一个索引的**

例如创建索引(A,B) 如果在创建索引(A)就是冗余索引，因为(A,B)索引相当有(A) (A,B)两个索引，(A)索引是(A,B)索引的前缀。

> 表中的索引越多会导致INSERT、UPDATE、DELETE等操作速度越来越慢，特别是当新增索引后导致达到了内存瓶颈的时候。