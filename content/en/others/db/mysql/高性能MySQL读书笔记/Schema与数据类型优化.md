---
title: Schema与数据类型优化
categories:
  - 数据库
  - MYSQL
  - 高性能MySQL读书笔记
tags:
  - 数据库
  - MYSQL
  - 高性能MySQL读书笔记
abbrlink: 26ac1f1c
date: 2019-03-29 14:28:24
---
从建表的角度来对提高数据库性能进行优化

### 1. 选择优化的数据类型

数据类型优化的原则：

- **更小的通常更好**

  尽量的使用可以正确存储数据的最小数据类型（**例如存0-200,tinyint**）。更小的数据类型通常更快 --- **占用更少的磁盘，内存，CPU缓存，并且处理时需要的CPU周期更少。**

- **简单就好**

  简单的数据类型的操作通常需要更少的CPU周期。整形比字符串操作代价更加低。因为字符集的排序规则比整型更加复杂。下面有两个例子：

  - 储存日期和时间应该使用MySQL內建的类型如：**`data time datatime`** 而不是用字符串来存储。

  - 用整数来存储IP地址

    ```mysql
    mysql> select inet_aton('192.168.0.1');
    +--------------------------+
    | inet_aton('192.168.0.1') |
    +--------------------------+
    |               3232235521 |
    +--------------------------+
    ```

    ```mysql
    mysql> select inet_ntoa(3232235521);
    +-----------------------+
    | inet_ntoa(3232235521) |
    +-----------------------+
    | 192.168.0.1           |
    +-----------------------+
    ```

    通过函数来转换存储。

- **尽量避免NULL**

  通常情况下NULL是列的默认属性，但是通常情况下最好指定为**Not NULL**。除非真的需要存储**NULL**值。----对于包含NULL的列，使得索引、索引统计、和值比较都更加复杂。可为NULL的列会使用更多的存储空间，MySQL中也需要特殊处理。当可为NULL的列被索引时，每个索引纪录需要一个额外的字节。

  所以在要建立索引的字段上尽量避免设计成为NULL的列。

### 2. 整数类型

- **整数**

  - **TINYINT**

    存储空间位数：8

  - **SMALLINT**

    存储空间位数：16

  - **MEDIUMINT**

    存储空间位数：24

  - **INT**

    存储空间位数：32

  - **BIGINT**

    存储空间位数：64

  整数类型可以选择UNSIGNED属性，表示不允许负数。无符号和有符号的存储空间一样，具有相同的性能。

  **整数类型指定宽度例如INT(11)，对于大多数引用来说没有意义。不会限制合法值的范围。对于储存和计算来说INT(1)和INT(11)都是一样的**

- **实数**

  实数是带有小数部分的数字。然而不只是为了存储小数部分；也可以使用DECIMAL存储比BIGINT还大的整数。float比DECIMAL更加快。原因是CPU支持浮点数运算而不支持DECIMAL运算。

### 3. 字符串类型

- **可变长度 `varchar`**

  比定长更加节省空间，因为他是按需分配。例外情况---Mysql表使用ROW_FORMAT=FIXED创建的话，每一行都会使用定长存储。

  **`varchar`** 会使用1或2个额外的字节来纪录字符串的长度：长度小于等于255字节，则使用一个字节，如果大于255小于等于65535 则使用两个字节(PS：这里可以看出来varchar的最大值65535，因为至多只有两个字段来纪录大小)。

    **`varchar`** 的好处就是节省空间。能够提高性能，但是同样的由于是变长在更新(**UPDATE**)时候可能使行变得更加长。如果一个行占用的空间增长，并且页内没有更多的空间可以存储，在这种情况下不同的引擎处理的方式不一样，InnoDB需要分裂页来使得行可以放到页内。

- **固定长度 `char`**

  char是固定长度，根据定义的长度分配足够的空间。当存储char值时MySQL会去除掉后面的空字符串。

  ```sql
  INSERT INTO chartest VALUES (2,' char1 ');
  SELECT CONCAT("'",char_col,"'") FROM chartest WHERE char_col = ' char1 ';
  ```

  如上两条语句查询出来的数据是去除了char1后面的空字符。查询的时候也可以去除后面空字符也能查询出来。

  char比较适合存储一些比**较短或者定长**的字符串。比如MD5。对于经常变更的数据，char也比varchar好。定长的char不容易产生碎片。 对于非常短的列，char比varchar在存储空间上也更有效率。

  > 使用VARCHAR(5)和VARCHAR(200)存储 hello 的空间开销是一样的。那么使用更短的列有什么优势？
  >
  > 更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部的值。尤其是使用内存临时表时表进行排序或者操作时会特别糟糕。在利用磁盘临时表进行排序时也同样的糟糕。
  > 所以最好的策略就是只分配正则需要的空间，用多少分配多少，估算当前列的最大值。这个也符合数据库的优化。更小的通常更好

### 4. BLOB和TEXT类型

这两个类型都是为了存储很大的数据设计的，分别采用二进制和字符串方式存储。MySQL把每一BLOB和TEXT值当做一个独立的对象处理。存储引擎通常会做特殊处理。当BLOB和TEXT值太大时，InnoDB会使用专门的**外部**存储区域来进行存储，此时每一个值在行内需要1~4个直接存储一个指针，然后外部存储区域存储实际的值。

MySQL对BLOB和TEXT列进行白鞋与其他类型是不同的。**只对每个列的最前max_sort_length字节而不是整个字符串做排序，可以通过配置max_sort_length的配置设置**

> 磁盘临时表和文件排序
>
> 尽可能的避免使用BLOB和TEXT类型。如果实在无法避免，有一个技巧就是在说用到的BLOB字段的地方都使用SUBSTRING(column,length)将列值转换为字符串(在order by中也适用)，这样就能用到内存临时表了，但是要确保截取的子字符串足够短。不会使临时表的大小超过max_heap_table_size或tmp_table_size,超过以后会会将内存临时表转换为MyISAM磁盘临时表。
>
> 如果EXPLAIN执行计划的Extra列包含"Using temporary",这说明这个查询使用了隐私临时表

### 5. 使用枚举(ENUM)代替字符串类型

有时候可以使用枚举代替常用的字符类型(种类固定不会轻易改动：例如性别，开关，订单状态等等)。枚举在MySQL内部的存储枚举非常紧凑。会根据值的数量压缩到一个或者两个字节。(尽量避免使用数字来作为枚举，双重性很容易导致混乱)

枚举的不好之处：字符串列表都是固定的，添加或者删除字符串都必须使用alter table。

```sql
alter table `enum_test` modify column  `e` enum('dog','cat','ant','fish');
```

> 在遇到关联查询的时候，最好是同一类型的数据进行关联，这样能提高查询速度。如果是不同的数据进行关联可能会造成比较慢的情况。测试发现ENUM和VARCHAR关联比VARCHAR和VARCHAR关联慢。整数之间的关联速度更快，把一些列转换成ENUM可以缩减表的大小，如果是联合主键会降低主键的大小，同时会降低二级索引的整个大小。

### 6. 日期和时间类型

MySQL可以使用许多类型来保存日期和时间值，例如YEAR和DATE。MySQL能存储的最小时间粒度为秒。

- **DATETIME**

  用8个直接存储，与时区无关。

- **TIMESTAMP**

​      保存了从1970年格林尼治时间以来的秒数。用4个字节的存储空间，范围比DATETIME小的多。

### 7.  特殊的类型数据

某些类型的数据并不直接与内置的数据一样。低于秒级精度时间。

IP的例子，在数据可以用无符号的32位整数进行存储。MySQL提供INET_ATON()和INET_NTOA()函数之间转换。